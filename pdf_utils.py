THE_PROGRAM="pdf_utils.py"
THE_VERSION="1.0.0"
THE_AUTHOR="Antonio Romeo"
THE_DATE="2025-06-28"
THE_COPYRIGHT="Antonio Romeo Â© 2024, 2025"
THE_LICENSE="MIT License"

#this file read a job description from JOB_DESCRIPTION_FILENAME and all CVs in pdf format contained in PDF_FOLDER
#and give an evaluation of the CVs based on the job description
import os
import time
import base64
import fitz  # PyMuPDFrr
import pdfplumber
import json
import openai

import openai_answers_decoder as oad
from rom_print import printColor, debugLog, printTwoColors
from AIConversation import AIConversation, AIC_ROLE_USER, AIC_TYPE_IMAGE_URL


#Example of environment variables pointing to Azure openai instance
AZURE_GPT_KEY           = os.getenv("AZURE_GPT4O_KEY")    #(deployment name) Example: 2348feh787hf38734843hf8743h743h (not a real key)
AZURE_GPT_EP            = os.getenv("AZURE_GPT4O_EP")     #(endpoint) Example: https://something.openai.azure.com/
AZURE_GPT_DEPLOY        = os.getenv("AZURE_GPT4O_DEP")    #(deployment name) Example: my-gpt-4o-dep
AZURE_GPT_VER           = os.getenv("AZURE_GPT4O_VER")    #(api_version) Example: 2024-05-01-preview
AZURE_GPT_MODEL         = os.getenv("AZURE_GPT4O_MODEL")  #(model name) Example: gpt-4o

IS_VISION_SUPPORTED:bool     = True
IS_AUDIO_SUPPORTED:bool      = False

MAX_TOTAL_TOKENS: int        = 128000
DEFAULT_RESPONSE_TOKENS: int = 4096
MAX_RESPONSE_TOKENS: int     = 16384

ROLE_USER        = "user"
ROLE_SYSTEM      = "system"

def get_file_date(file_path: str) -> str:
    """
    Get the date of the file in the format YYYY-MM-DD.
    If the file does not exist, return None.
    """
    result:str = None
    if not os.path.exists(file_path):
        result =  None
    else:
        # Get the last modified time of the file
        timestamp = os.path.getmtime(file_path)
        
        # Convert the timestamp to a datetime object
        result = time.strftime("%Y-%m-%d", time.localtime(timestamp))
    
    return result

def cleanNonPrintableChars(text_content:str)->str:
    """ clean a string of all non-printable charachters like NUL etc... """
    #clean the string of all non-printable characters
    #text_content = ''.join([i if ord(i) < 128 else ' ' for i in text_content])
    text_content = ''.join([i if ord(i) < 128 else '' for i in text_content])
    return text_content

def makeValidFilename(the_string:str)->str:
    """
    Make a valid filename by replacing invalid characters with the specified character.
    """
    # Define a regex pattern to match invalid characters
    valid_filename:str = cleanNonPrintableChars(the_string)
    invalid_chars = r'<>:"/\\|?*'
    for char in invalid_chars:
        # Replace invalid characters with an underscore
        valid_filename = valid_filename.replace(char, "_")
    
    return valid_filename

def getAnswerFromAIConversation(l_conversation: AIConversation, throttle_seconds:int=1, max_retries:int=3, backoff_factor:int=5, MAX_RESPONSE_TOKENS:int=MAX_RESPONSE_TOKENS)->str:
    """
    get a single answer (string) from an AIConversation object using the Azure OpenAI model.

    Parameters:
    - l_conversation: AIConversation (optional) - The conversation object containing the messages exchanged with the AI model.
    - the_open_ai_model_size: str (optional) - The size of the Azure OpenAI model to use.
    - throttle_seconds: int (optional) - The number of seconds to wait between API requests.
    - max_retries: int (optional) - The maximum number of retries in case of API errors.
    - backoff_factor: int (optional) - The factor by which to increase the delay between retries.
    - L_MAX_RESPONSE_TOKENS: int (optional) - The maximum number of tokens in the response.

    Returns:
    - str: The answer generated by the AI model.
    """
    current_retry = 0
    g_delay: int = throttle_seconds
    response = None
    azureopenaiclient                = openai.AzureOpenAI(api_key=AZURE_GPT_KEY, api_version=AZURE_GPT_VER, azure_endpoint=AZURE_GPT_EP)
    azureopenaiclient.api_type       = "Azure"
    azureopenaiclient.api_key        = AZURE_GPT_KEY
    azureopenaiclient.api_base       = AZURE_GPT_EP
    azureopenaiclient.api_version    = AZURE_GPT_VER


    the_payload:list[dict[str, str]] = l_conversation.get_conversation_python_memory_payload()
    answer: str = ""
    last_retry:int = 0

    while current_retry < max_retries:
        try:
            current_deploy: str                = AZURE_GPT_DEPLOY

            json_response = None

            response = azureopenaiclient.chat.completions.create(
                            model    = current_deploy,
                            messages = the_payload,
                            temperature=0.7,
                            max_tokens=MAX_RESPONSE_TOKENS,
                            top_p=0.95,
                            frequency_penalty=0,
                            presence_penalty=0,
                            stop="", 
                            stream=False)

            json_response = json.loads(response.model_dump_json(indent=2))
            answer = oad.get_content(json_response)
            
            if answer is None or answer.strip() == "":
                answer = "Got NO Answers"

            debugLog("BOT: " + answer, "green", calling_function="getAnswerFromAIConversation")

            total_tokens           = oad.get_total_tokens(json_response)
            completion_tokens      = oad.get_completion_tokens(json_response)
            prompt_tokens          = oad.get_prompt_tokens(json_response)
            debugLog("total_tokens.....: " + str(total_tokens), "yellow", calling_function="getAnswerFromAIConversation")
            debugLog("completion_tokens: " + str(completion_tokens), "yellow", calling_function="getAnswerFromAIConversation")
            debugLog("prompt_tokens....: " + str(prompt_tokens), "yellow", calling_function="getAnswerFromAIConversation")

            break


        except openai.APITimeoutError as e:
            printColor(f"Retry {current_retry} - APITimeoutError occurred: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += (max_retries + 1)   #force exit later 

            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00001")

            eccezione:str = str(e)
            debugLog("APITimeoutError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00002-")
            continue

        except openai.APIConnectionError as e:
            printColor(f"Retry {current_retry} - APIConnectionError: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1 
            
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00003")

            eccezione:str = str(e)
            debugLog("APIConnectionError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00004")
            continue


        except openai.BadRequestError as e:
            printColor(f"Retry {current_retry} - BadRequestError: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1 
            
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00005")
            
            eccezione:str = str(e)                
            debugLog("Invalid request: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00006")
            
            continue

        except openai.AuthenticationError as e:
            printColor(f"Retry {current_retry} - AuthenticationError: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later on since there is no way to change credentials without rebooting

            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00007")

            eccezione:str = str(e)
            debugLog("AuthenticationError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00008")
            continue


        except openai.PermissionDeniedError as e:
            printColor(f"Retry {current_retry} - PermissionDeniedError: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later on since there is no way to change credentials without rebooting
            
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00009")

            eccezione:str = str(e)
            debugLog("PermissionDeniedError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00010")
            continue

        except openai.RateLimitError as e:
            printColor(f"Retry {current_retry} - RateLimitError exceeded: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += 1

            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00011")

            eccezione:str = str(e)
            debugLog("Rate limit exceeded: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00012")
            #if the max number of tokens has been passed, retry with a lower number of tokens (remove 2 oldest messages)
            if "Please retry after" in eccezione:
                #extract the number following the "Please retry after"
                g_delay: int = int(eccezione.split("Please retry after ")[1].split(" seconds")[0])+1
            else:
                g_delay *= backoff_factor

            print(f"Error: {e}")

            if current_retry <= max_retries:
                printColor(f"Attempt {current_retry} of {max_retries} failed. Retrying in {g_delay} seconds...", "red")
                # Wait for the specified delay before retrying
                time.sleep(g_delay)

            else:
                printColor(f"Attempt {current_retry} of {max_retries} failed. No more retries...", "red")
                
            continue

        except openai.ConflictError as e:
            printColor(f"Retry {current_retry} - A ConflictError occurred: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later 
            eccezione:str = str(e)
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00014")

            debugLog("openai.ConflictError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00015")
            continue

        except openai.InternalServerError as e:
            printColor(f"Retry {current_retry} - An InternalServerError occurred: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later 
            
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00015")
            
            eccezione:str = str(e)
            debugLog("openai.InternalServerError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00016")
            continue

        except openai.APIStatusError as e:
            printColor(f"Retry {current_retry} - APIStatusError occurred: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later 
            
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00017")
            
            eccezione:str = str(e)
            debugLog("openai.APIStatusError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00018")
            continue
        
        except openai.APIResponseValidationError as e:
            printColor(f"Retry {current_retry} - APIResponseValidationError occurred: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later 
            
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00019")
                            
            eccezione:str = str(e)
            debugLog("openai.APIResponseValidationError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00020")
            continue                

        except openai.APIError as e:
            printColor(f"Retry {current_retry} - APIError: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1 
            
            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00021")
                                            
            eccezione:str = str(e)
            debugLog("APIError: " + eccezione, "red", "getAnswerFromAIConversation-DBG.0066M")
            continue

        except openai.OpenAIError as e:
            printColor(f"Retry {current_retry} - General OpenAIError: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later 

            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00022")
                                            
            eccezione:str = str(e)
            debugLog("General OpenAI error: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00023")
            continue

        except Exception as e:
            printColor(f"Retry {current_retry} - Exception (generic) occurred: {e}", "red")
            last_retry     = current_retry + 1
            current_retry += max_retries + 1   #force exit later 

            if response is not None:
                response_str=str(response)
                debugLog("Response: " + response_str, "red", "getAnswerFromAIConversation-DBG.B00024")

            eccezione:str = str(e)
            debugLog("General Exception: " + eccezione, "red", "getAnswerFromAIConversation-DBG.B00025")
            continue

    if current_retry > max_retries:
        printColor(f"LOG.B0001 - All attempts to connect to the Azure OpenAI server failed. {last_retry} times", "red")
        # If all retries fail, raise an exception or return an appropriate value
        #raise ConnectionError("myLocalChatGPT: All attempts to connect to the Azure OpenAI server failed.")

    return answer


def pdf_to_images_to_filename(pdf_full_path:str, use_page_no:int = 1) ->str:
    """
        Get a filename from the n-th page of the pdf file.

        This Utility function is used to generate a filename based on the content of the n-th page of the PDF.
        It uses Azure OpenAI to analyze the n-th page (default is the first) and generate a filename.

        :params pdf_path: Full path of the PDF file to convert.
        :params use_page_no: The page number to use for generating the filename (default is page 1).

        :return: a filename for the pdf file, based on the first page content.
        If the filename cannot be generated, returns None.
    """

    new_filename: str  = None

    index_to_use: int = use_page_no-1
    pdf_document = fitz.open(pdf_full_path)
    pdf_length:int = len(pdf_document)

    if index_to_use < 0 or index_to_use >= pdf_length:
        new_filename =  None # type: ignore[reportAssignmentType]
    else:
        # Open the PDF
        
        page = pdf_document[index_to_use]
        
        pix = page.get_pixmap()  # type: ignore[attr-defined]


        base_64_pix: str = base64.b64encode(pix.tobytes(output="png")).decode("utf-8")  # Convert to base64 string

        my_prompt = "You are a meticulous assistant helping me to classify documents and generate correct filenames."\
                        "I will pass you an image with a page of a document and you will return a new filename I can use to save the document. "\
                        "The filename MUST start with a date in the format YYYY-MM-DD, followed by the name of the issuing entity, "\
                        "the type of document, the title of the document if present, what the document is about, and the period if applicable and "\
                        "when applicable, the object of the transaction (a stock, a bond, on object acquired, a service, a payment, a receipt, a contract, etc.). "\
                        "The output should be a string with the following format: "\
                        "YYYY-MM-DD - Ente Emittente - Tipo Documento - Titolo del documento - Cosa Riguarda - Periodo. "\
                        "Examples"\
                        "A bank statement from BANKX for the month of March 2024:"\
                        "   output:   '2024-03-01 - BANKX - Estratto Conto - Marzo 2024'"\
                        "A receipt from Enel for the month of January 2025:"\
                        "   output:   '2025-01-01 - Enel - Ricevuta - Gennaio 2025'. "\
                        "A contract from Banca Intesa for the year 2025:"\
                        "   output:   '2024-01-01 - Banca Intesa - Contratto - 2025'. "\
                        "A receipt from American Express for the month of January 2025:"\
                        "   output:   '2025-01-01 - American Express - Ricevuta - Gennaio 2025'."\
                        "A generic contract then the format should be"\
                        "       YYYY-MM-DD - Ente o persona Emittente - Tipo Documento - Titolo del documento - Cosa Riguarda - Periodo. "\
                        "A printed document, email, letter or anything with a 'subject' or 'title' field:"\
                        "   output:   'YYYY-MM-DD - destinatario - Tipo Documento - subject o Titolo del documento - Cosa Riguarda - Periodo'."\
                        "A document with no date, then the format should be"\
                        "   output:   '0000-00-00 - destinatario - Tipo Documento - Titolo del documento - Cosa Riguarda - Periodo'."\
                        "EXTRAS:"\
                        "The date, must always be in the format YYYY-MM-DD, should be the date of the document, or the expiration date,"\
                        "or the date of the last update, the issue date, or the date of signature."\
                        "if there is no date at all and one cannot be meaningfully inferred, use 0000-00-00 as date."\
                        "if it is just a graphic/image/diagram with no dates in it, just give a short description of the content and use '0000-00-00' as the date for the filename."\
                        "NEVER use special characters, spaces, slashes, backslashes, stars  or punctuation in the filename."\
                        "The output MUST be only the new proposed filename as a SINGLE LINE STRING, with no explanation or additional text."

    
  
        max_retries = 3
        backoff_factor = 2
        loc_delay: int = 5 #aka     throttle_seconds = 5

        my_conversation = AIConversation(my_prompt)
        my_conversation.add_message("user", "Give me a filename for this image", "image_url", f"data:image/jpeg;base64,{base_64_pix}")

        answer: str = getAnswerFromAIConversation(my_conversation, throttle_seconds=loc_delay, max_retries=max_retries, backoff_factor=backoff_factor, MAX_RESPONSE_TOKENS=128)
        if answer is not None and  answer.strip() != "":
            answer = makeValidFilename(answer)
            new_filename = answer.strip()
        else:
            printColor("pdf_to_images_to_filename() - No answer from Azure OpenAI. Cannot generate a filename.", "red")
            new_filename = None

    pdf_document.close()
    return new_filename

def image_file_to_text(the_image_path:str) -> str:
    the_result:str = ""
    
    the_prompt: str = """You are a renowned expert in Optical Character Recognition (OCR) and document digitization tools. 
                            You will assist on the following tasks:
                            - Extracting accurate textual information from scanned images of documents.
                            - Preserving and interpreting the original meaning and context of the scanned document content.
                            - Correctly identifying and preserving formatting-related elements such as paragraphs, headings, lists, tables, and numerical data.
                            - Detecting and repairing potential errors or inaccuracies during text conversion.
                            - Producing finalized text outputs formatted clearly and naturally, suitable for immediate usability.

                            Examples specific to your tasks include:
                            - Converting scanned letters, contracts, or professional reports into consistently formatted, well-structured, and easily readable text documents.
                            - Extracting formatted and structured text data accurately from scanned financial statements, preserving numerical accuracy, columns, tables, and proper labeling of data.
                            - Digitizing scanned articles, preserving paragraphs, sections, headlines, and bullet-points, and maintaining original meanings and intentions of the source authors.
                            - Analyzing images of historical documents or manuscripts, carefully preserving context, annotations or handwritten notes within extracted text.
                            - Automatically identifying and correcting possible conversion errors in extracted digital text such as misrecognized characters, misspelled words, or formatting issues.

                            Your output must be delivered as clearly structured plaintext, properly segmented into logical paragraphs, sections, or tables, 
                            maintaining readability, formatting integrity, meaning, and contextual accuracy. 
                            Avoid typical machine-like inaccuracies or formatting mistakes, instead delivering text conversions that reflect expertise, 
                            clarity, and professional accuracy typical of an OCR industry-leading expert.
                            Use for the output the same language of the input text.
                            Do not add any comment, just the text.
                            """

    chat_conversation = AIConversation(the_prompt, 3)

    #chat_conversation.add_message(AIC_ROLE_USER, the_image_path, AIC_TYPE_IMAGE_URL)
    chat_conversation.add_message(ROLE_USER, "Please extract the text from the image", AIC_TYPE_IMAGE_URL, the_image_path)
    the_result = getAnswerFromAIConversation(chat_conversation)

    return the_result


def pdf_to_images_to_text(pdf_full_path:str, max_pages:int=0) ->str:
    """
    Converts each page of a PDF into an image (JPEG).
    Extracts the text and puts all pages into a single text file (.DONE.txt).
    
    SIDE EFFECTS: Creates a folder with the same name as the PDF file, containing all images and text files.!!!

        :param pdf_path: Full path of the PDF file to convert.
        :param max_pages: Maximum number of pages to convert. If 0, all pages are converted. 0 means all pages.
        :return: Full path of the text file containing all pages' text. 
    """

    pdf_dir_only = os.path.dirname(pdf_full_path)  # Directory del file PDF
    pdf_name_only = os.path.basename(pdf_full_path)
    pdf_name_only_noext = os.path.splitext(pdf_name_only)[0]  # Nome del file PDF senza estensione
    IMAGE_FILE_EXT = 'png'
    TEXT_FILE_EXT  = 'txt'
    txt_full_path = os.path.splitext(pdf_full_path)[0] + "DONE.txt"

    # Create a directory with the filename and .JPG as extension
    image_folder = os.path.join(pdf_dir_only, pdf_name_only_noext, IMAGE_FILE_EXT)
    os.makedirs(image_folder, exist_ok=True)
    
    text_folder = os.path.join(pdf_dir_only, pdf_name_only_noext, pdf_name_only_noext, TEXT_FILE_EXT)
    os.makedirs(text_folder, exist_ok=True)

    # Open the PDF
    pdf_document = fitz.open(pdf_full_path)

    pdf_length:int = len(pdf_document)
    my_max_pages:int = min(max_pages, pdf_length) if max_pages > 0 else pdf_length  # If max_pages is 0, convert all pages

    for page_number in range(my_max_pages):
        page = pdf_document[page_number]
        pix = page.get_pixmap()  # type: ignore[attr-defined]

        png_filename = os.path.join(image_folder, f'{pdf_name_only_noext}-page_{page_number}.{IMAGE_FILE_EXT}')
        txt_filename:str  = os.path.join(text_folder,  f'{pdf_name_only_noext}-page_{page_number}.{TEXT_FILE_EXT}')
    
        pix.save(png_filename)  # Save the image as PNG
        print(f"Page {page_number + 1} saved as {png_filename}")

        the_text:str = image_file_to_text(png_filename)
        printTwoColors(f"Page {page_number} converted to TXT: ", "pink", txt_filename, "white")

        with open(txt_filename, "w", encoding="utf-8") as text_file:
            text_file.write(the_text)
        
        #write an overall text file with all the pages
        printTwoColors(f"Page {page_number} added to TXT: ", "pink", txt_full_path, "white")
        with open(txt_full_path, "a", encoding="utf-8") as text_file:
            text_file.write(the_text)
            text_file.write("\n\n")

    pdf_document.close()

    printTwoColors(f"PDF {pdf_name_only} converted to images and text.", "green", pdf_full_path, "white")
    return txt_full_path

def read_pdfs_from_folder_with_pdfplumber(folder_path: str) -> list[dict[str, str]]:
    pdf_files = []
    for filename in os.listdir(folder_path):
        if filename.endswith(".pdf"):
            pdf_path = os.path.join(folder_path, filename)
            try:
                with pdfplumber.open(pdf_path) as pdf:
                    text = ""
                    for page in pdf.pages:
                        text += page.extract_text()

                    pdf_files.append({"filename": pdf_path, "filecontent": text})
            except Exception as e:
                print(f"Error reading {pdf_path}: {e}")
    return pdf_files



def list_pdf_in_folder(folder_path: str) -> list[str]:
    """
    Lists all PDF files in the specified folder.
    :param folder_path: Path to the folder where PDF files are located.
    :return: List of full paths to PDF files in the folder.
    """

    pdf_files: list [str]  = []

    for filename in os.listdir(folder_path):
        if filename.endswith(".pdf"):
            pdf_path: str = os.path.join(folder_path, filename)
            pdf_files.append(pdf_path)

    return pdf_files


if __name__ == '__main__':
    print("pdf_utils.py - not an executable module.")

    print(fitz.version)
    print(fitz)
# This module is not intended to be run directly.
